\documentclass[a4paper,10pt]{article}

\usepackage[dutch]{babel}
\usepackage{a4wide}

\title{Project Formele Systeemmodellering voor Software}
\author{Bruno Corijn, Jasper Vander Jeugt, Toon Willems}
\date{\today}

\begin{document}
\maketitle
\section{Deel 1: ACL2}
Voor de priority-queue drie versies terug te vinden. Oorspronkelijk waren we begonnen met de queue te implementeren als een binomial heap. Dit heeft als voordeel, veel sneller te zijn dan de andere alternatieven zonder veel extra implementatie. Als nadeel was de formele verificatie echter veel moeilijker te bewijzen. Hierna hebben we het geprobeerd met een linked list, wat net het tegenovergesteld was van de binomial heap. Dit was zeer makkelijk te bewijzen maar was echter ook zeer traag om te gebruiken, waardoor we ook dit niet verder hebben uitgewerkt. Uiteindelijk hebben we gekozen voor een binaire boom. In het slechtste geval zal ook deze datastructuur traag werken, gezien er niet wordt geherbalanceerd maar gemiddeld zal deze implementatie sneller zijn dan de linked list.

\subsection{Formele Specificaties}
De specificaties zijn terug te vinden als theorems, die gebruik maken van enkele hulp functies. Deze functies controleren de volgende zaken: of alle elementen in de queue een kleinere prioriteit hebben dan een gegeven \emph{x}, of alle elementen in de queue een grotere of gelijke prioriteit hebben aan een gegeven \emph{x}, of er een element met prioriteit \emph{k} en value \emph{v} terug te vinden is in een gegeven queue en of de ordening van de gehele boom correct is.

Bij de theorema\'s specifi\"eren we het gedrag van de priority queue en controleren we dat de correctheid bewaard blijft. In de code is er bij elk theorema commentaar voorzien zodat het duidelijk zou moeten zijn waartoe het onderstaand theorema dient.

\subsection{Implementatie}
De belangrijkste functies uit de API zijn \emph{queue-insert (k v queue)}, die recursief een nieuwe boom zal opbouwen waar de value \emph{v} met prioriteit \emph{k} aan toegevoegd is. Indien de queue leeg is, wordt er een nieuw singleton aangemaakt. 

\emph{Queue-find-min(queue)} zal het element met de kleinste prioriteit  teruggeven, wat neerkomt op recursief het meest linkse kind in de boom te zoeken. De \emph{queue-delete-min(queue)} functie zal dit element verwijderen uit de boom door een nieuwe queue op te bouwen waar dit element niet meer in te vinden is.  

\emph{Queue-merge (q1 q2)} zal zoals de naam laat vermoeden, 2 queues mergen. Hiervoor voegen we eerst het rechterkind van \emph{q1} aan \emph{q2} toe aan de hand van de \emph{queue-insert} functie, vervolgens het linkerkind en als laatste het element zelf. 

Als laatste functionaliteit hebben we \emph{queue-change-priority(k v queue)}, dit zal een nieuwe lijst opbouwen waarbij alle elementen van \emph{queue} gekopieerd worden buiten het element met value \emph{v}, waar we de nieuwe prioriteit \emph{k} aan zullen toekennen.

\subsection{Verificatie}

De output van de automatische verificatie van de implementatie als binaire boom is te vinden als bijlage aan ons verslag. 


\section{Deel2: TLA/TLC}


\end{document}